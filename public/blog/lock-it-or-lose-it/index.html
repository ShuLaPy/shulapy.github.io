<!DOCTYPE html>




































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Lock It or Lose It: Avoiding Race Conditions in Distributed Systems - Shubham Lad</title>

  
  <meta name="theme-color" />

  
  
  
  <meta name="description" content="
Hey folks! 👋 Ever dealt with that frustrating feeling when two things try to happen at once, and everything ends up in a mess? That’s exactly what race conditions do in distributed systems! But don’t worry—today, I’ll walk you through how pessimistic locking steps in to save the day. We’ll keep things simple and easy to follow. Ready? Let’s jump in!
What’s a Race Condition? And Why Should You Care?
Imagin this: You and your friend both try to withdraw cash from the same account, at the exact same time. There’s only ₹5,000 in the account, but somehow, both of you manage to withdraw ₹5,000 each. That’s double the money! 🎩✨ While this might sound great at first, it’s a nightmare for banks and a perfect example of a race condition." />
  <meta name="author" content="Brief Description" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="http://localhost:1313/main.min.css" />

  
  <script
    defer
    src="http://localhost:1313/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
   
  <link rel="preload" as="image" href="http://localhost:1313/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/733ed220a859026ff7dba915d2c1c693?s=160&amp;d=identicon" />
  
  

  
  

  
  

  
  <link rel="icon" href="http://localhost:1313/favicon.ico" />
  <link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.135.0">

  
  

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="http://localhost:1313/"
      >Shubham Lad</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/blog/"
        >📝 Blog</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/papershelf/"
        >📑 Papershelf</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/bookshelf/"
        >📚 Bookshelf</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/about/"
        >😎 About Me</a
      >
      
    </nav>
    

    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">Lock It or Lose It: Avoiding Race Conditions in Distributed Systems</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Oct 21, 2024</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExZHRwYXQ0em14ODI5OGR6bWkwMTVuNDQ4Z2l5dXFsYnpzODN5cmJ1eiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3ohzdFvSAgvmXq6n2o/giphy.gif" alt="lock-it"></p>
<p>Hey folks! 👋 Ever dealt with that frustrating feeling when two things try to happen at once, and everything ends up in a mess? That’s exactly what race conditions do in distributed systems! But don’t worry—today, I’ll walk you through how <strong>pessimistic locking</strong> steps in to save the day. We’ll keep things simple and easy to follow. Ready? Let’s jump in!</p>
<h2 id="whats-a-race-condition-and-why-should-you-care">What’s a Race Condition? And Why Should You Care?</h2>
<p>Imagin this: You and your friend both try to withdraw cash from the same account, at the exact same time. There’s only ₹5,000 in the account, but somehow, both of you manage to withdraw ₹5,000 each. That’s double the money! 🎩✨ While this might sound great at first, it’s a nightmare for banks and a perfect example of a <strong>race condition</strong>.</p>
<p>In tech terms, a race condition happens when two or more processes try to access or update the same data at the same time. If there’s no proper control, things can go wrong—like data getting corrupted or lost.</p>
<p>Distributed systems, where multiple services or nodes interact with the same data, are especially vulnerable to these issues. That’s where pessimistic locking steps in, acting like a bouncer at a club. 🚪</p>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515003/Blog/vqcb77v17q5xyyzegfkj.png" alt="diagram-1"></p>
<h2 id="what-exactly-is-pessimistic-locking">What Exactly is Pessimistic Locking?</h2>
<p>Alright, let’s talk about pessimistic locking. Think of it as assuming the worst: “If I don’t block access to this data now, someone else will mess it up.” So, the system locks the resource upfront, preventing anyone else from touching it until the first process finishes.</p>
<p>Imagine you’re booking a seat for a movie. As soon as you confirm the booking, that specific seat is “locked” for you—no one else can book it until your transaction is complete. The same logic applies in distributed systems. If one process locks a piece of data, all other processes have to wait patiently until the lock is released.</p>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515003/Blog/rqwcsdxsn7gcg8tpjw4l.png" alt="daigram-2"></p>
<h2 id="how-does-pessimistic-locking-work">How Does Pessimistic Locking Work?</h2>
<p>Here’s a quick breakdown of how pessimistic locking works when multiple nodes or services are involved:</p>
<h4 id="1-lock-the-resource-">1. Lock the Resource 🛑</h4>
<ul>
<li>Let’s say Node A wants to update a record. Before it does anything, it locks the resource so no one else can touch it.</li>
</ul>
<h4 id="2-exclusive-access-">2. Exclusive Access 🔒</h4>
<ul>
<li>While Node A holds the lock, other nodes (like Node B) can’t make changes. They’ll just have to wait until the lock is released.</li>
</ul>
<h4 id="3-release-the-lock-">3. Release the Lock 🗝️</h4>
<ul>
<li>When Node A finishes its work, it releases the lock, giving other nodes the green light to proceed.</li>
</ul>
<h2 id="pessimistic-locking-in-distributed-systems">Pessimistic Locking in Distributed Systems</h2>
<p>At a high level, locking in distributed systems works pretty much the same way as described earlier. But things get trickier because distributed systems have their own challenges—like node failures, replacements, or network partitions—which add complexity.</p>
<p>In these systems, a cluster-wide lock database keeps track of which node holds the lock on which resource. Every time a node acquires or releases a lock, this database is updated to reflect the change.</p>
<h3 id="acquiring-a-lock-is-just-the-start--lease-matters">Acquiring a Lock is Just the Start — Lease Matters</h3>
<p>Let’s say Node A locks a shared resource (like an account balance) to update it. But right after acquiring the lock, Node A crashes or gets stuck, leaving the lock hanging. Now, other nodes (like Node B) trying to access the same resource are stuck waiting indefinitely because the system thinks Node A still holds the lock.</p>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515003/Blog/jsi5hmj9f1mwndoe0sa9.png" alt="diagram-3"></p>
<p>This is where <strong>timeout handling</strong> saves the day! ⏲️</p>
<h4 id="1-setting-a-timeout">1. Setting a Timeout:</h4>
<ul>
<li>When Node A acquires the lock, the system assigns a timeout value say, 10 seconds. This means that if the node doesn’t release the lock within 10 seconds, the system will automatically release it.</li>
</ul>
<h4 id="2-what-happens-if-node-a-crashes">2. What Happens if Node A Crashes?</h4>
<ul>
<li>If Node A crashes before releasing the lock, the timeout kicks in. After 10 seconds, the system assumes something went wrong and frees the lock.</li>
</ul>
<h4 id="3-what-happens-next">3. What Happens Next?</h4>
<ul>
<li>Now that the lock is released, Node B (or any other waiting node) can jump in and acquire the lock to access the resource safely.</li>
</ul>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515003/Blog/y9xelgi50kqtcptnpiai.png" alt="diagram-4"></p>
<h3 id="why-timeout-handling-is-important">Why Timeout Handling is Important</h3>
<p>Without a timeout mechanism, the system could get stuck in a deadlock if the lock isn’t released. With timeouts in place, the system stays healthy, and processes don’t have to wait forever.</p>
<p>In real-world distributed systems, dynamically adjustable timeouts are often used to match the complexity of the operation—longer for intensive tasks and shorter for quick ones. This ensures a good balance between performance and safety.</p>
<h2 id="scenario-node-pauses-resumes-and-causes-stale-updates">Scenario: Node Pauses, Resumes, and Causes Stale Updates</h2>
<p>Imagine Node A acquires a lock on a shared resource (e.g., a user’s account balance) and starts processing some updates. But suddenly, Node A gets paused—maybe due to a network glitch or a system delay (like being swapped to disk). While Node A is paused, Node B steps in, notices the lock has expired (thanks to the timeout), acquires the lock, and updates the resource with new values.</p>
<p>Later, Node A resumes, unaware that the lock it held is no longer valid. It continues from where it left off, thinking it still owns the lock, and overwrites the changes made by Node B. This creates a stale update issue, leading to data inconsistency.</p>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515004/Blog/ailfgjy5zfe3kl8hhpfe.png" alt="diagram-5"></p>
<h2 id="fence-tokens-helps-to-avoid-stale-updates">Fence Tokens Helps to Avoid Stale Updates</h2>
<p>A fence token is like a version number or unique ID that increments with every lock acquisition. Here’s how it helps prevent stale updates:</p>
<h4 id="1-lock-acquisition-with-a-fence-token">1. Lock Acquisition with a Fence Token:</h4>
<ul>
<li>When Node A acquires the lock, it receives Fence Token = 1.</li>
<li>After Node A is paused and Node B acquires the lock, the system increments the token, and Node B gets Fence Token = 2.</li>
</ul>
<h4 id="2-including-fence-token-in-updates">2. Including Fence Token in Updates:</h4>
<ul>
<li>Every time a node makes a change to the resource, it sends the fence token along with the update.</li>
<li>The resource only accepts updates if the fence token matches the latest version it knows about.</li>
</ul>
<h4 id="3-node-as-resume-and-attempted-update">3. Node A’s Resume and Attempted Update:</h4>
<ul>
<li>When Node A resumes and tries to push its stale updates, it sends Fence Token = 1.</li>
<li>But the resource knows the latest valid token is 2 (from Node B’s update), so it rejects Node A’s stale update.</li>
</ul>
<!-- raw HTML omitted -->
<p><img src="https://res.cloudinary.com/zeuadaprogramming/image/upload/v1729515003/Blog/gpzmftnp9a35j9vyhrkr.png" alt="diagram-6"></p>
<p>Using fence tokens ensures that even if a node resumes after being paused, it can’t overwrite more recent changes. This prevents stale data from creeping into the system, keeping the data consistent and reliable. It’s a simple yet effective way to handle issues that timeouts alone can’t solve.</p>
<p>This approach is often used in distributed databases and systems to maintain strong consistency, especially in environments prone to delays or unpredictable pauses.</p>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="http://localhost:1313/blog/git_reset_right_way/"
      ><span>Learning from mistakes - Revert/Reset the branch in right way.</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="http://localhost:1313/">Shubham Lad</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
